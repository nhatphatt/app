"""
Response Generator - Generates natural language responses

Creates contextual, personalized responses based on intent and conversation state.
Can use either templates (fallback) or Gemini AI (preferred).
"""

from typing import Dict, List, Optional
import random
import os


class ResponseGenerator:
    """
    Generates natural language responses for different intents
    """

    def __init__(self, db, use_ai: bool = False):
        self.db = db
        self.response_templates = self._load_response_templates()

        # Check GEMINI_API_KEY
        api_key = os.environ.get('GEMINI_API_KEY')
        print(f"[ResponseGenerator] Checking GEMINI_API_KEY...")
        print(f"[ResponseGenerator] use_ai parameter: {use_ai}")
        print(f"[ResponseGenerator] GEMINI_API_KEY exists: {api_key is not None}")
        if api_key:
            print(f"[ResponseGenerator] API key preview: {api_key[:10]}...{api_key[-4:]}")

        self.use_ai = use_ai and api_key is not None
        self.gemini_service = None

        print(f"[ResponseGenerator] Final use_ai value: {self.use_ai}")

        # Initialize Gemini if enabled
        if self.use_ai:
            print(f"[ResponseGenerator] Attempting to initialize Gemini...")
            try:
                from chatbot.gemini_service import GeminiService
                print(f"[ResponseGenerator] GeminiService imported successfully")
                self.gemini_service = GeminiService()
                print("‚úì Gemini AI enabled for response generation")
            except Exception as e:
                print(f"‚ö† Gemini AI not available: {e}")
                print("  Falling back to templates")
                import traceback
                traceback.print_exc()
                self.use_ai = False
        else:
            print(f"[ResponseGenerator] Skipping Gemini initialization (use_ai=False)")

    def _load_response_templates(self) -> Dict:
        """
        Define response templates for each intent
        """
        return {
            "greeting": [
                "Xin ch√†o! M√¨nh l√† tr·ª£ l√Ω AI c·ªßa qu√°n. B·∫°n mu·ªën g·ªçi m√≥n g√¨ h√¥m nay? üòä",
                "Ch√†o b·∫°n! M√¨nh ·ªü ƒë√¢y ƒë·ªÉ gi√∫p b·∫°n t√¨m m√≥n ngon. H√¥m nay b·∫°n mu·ªën ƒÉn g√¨ nh·ªâ?",
                "Hi! ƒê·ªÉ m√¨nh gi√∫p b·∫°n ch·ªçn m√≥n nh√©. B·∫°n mu·ªën xem g·ª£i √Ω kh√¥ng?"
            ],

            "thank": [
                "Kh√¥ng c√≥ chi ·∫°! Ch√∫c b·∫°n ƒÉn ngon mi·ªáng! üç¥",
                "R·∫•t vui ƒë∆∞·ª£c gi√∫p b·∫°n! H√£y g·ªçi m√¨nh n·∫øu c·∫ßn g√¨ nh√© üòä",
                "D·∫°, kh√¥ng c√≥ g√¨! Ch√∫c b·∫°n c√≥ b·ªØa ƒÉn tuy·ªát v·ªùi!"
            ],

            "goodbye": [
                "T·∫°m bi·ªát! H·∫πn g·∫∑p l·∫°i b·∫°n l·∫ßn sau! üëã",
                "Bye bye! Ch√∫c b·∫°n m·ªôt ng√†y t·ªët l√†nh! üòä",
                "H·∫πn g·∫∑p l·∫°i b·∫°n! Nh·ªõ gh√© l·∫°i qu√°n nh√©!"
            ],

            "help": [
                "M√¨nh c√≥ th·ªÉ gi√∫p b·∫°n:\n‚Ä¢ G·ª£i √Ω m√≥n ƒÉn ph√π h·ª£p\n‚Ä¢ ƒê·∫∑t m√≥n tr·ª±c ti·∫øp\n‚Ä¢ Xem gi·ªè h√†ng v√† thanh to√°n\n‚Ä¢ T√¨m m√≥n gi·∫£m gi√°, combo h·ªùi\n\nB·∫°n mu·ªën l√†m g√¨ nh·ªâ?"
            ],

            "fallback": [
                "Xin l·ªói, m√¨nh ch∆∞a hi·ªÉu r√µ √Ω b·∫°n l·∫Øm. B·∫°n c√≥ th·ªÉ n√≥i r√µ h∆°n ƒë∆∞·ª£c kh√¥ng?",
                "Hmm, m√¨nh ch∆∞a n·∫Øm ƒë∆∞·ª£c √Ω b·∫°n. B·∫°n mu·ªën g·ªçi m√≥n, xem g·ª£i √Ω hay h·ªèi v·ªÅ m√≥n n√†o ·∫°?",
                "M√¨nh h∆°i confused n√®. B·∫°n c√≥ th·ªÉ h·ªèi l·∫°i v·ªõi c√°ch kh√°c ƒë∆∞·ª£c kh√¥ng?"
            ]
        }

    async def generate_response(
        self,
        intent: str,
        entities: Dict,
        context: Dict,
        store_id: str,
        original_message: str = "",
        conversation_history: List[Dict] = None
    ) -> Dict:
        """
        Generate response based on intent and context

        Returns:
            Dict with text, rich_content, and suggested_actions
        """
        response_type = intent

        # Use Gemini AI for natural responses if available
        if self.use_ai and self.gemini_service and original_message:
            try:
                # Get menu items for context (for recommendation/menu/promotion intents)
                menu_items = None
                if intent in ["ask_recommendation", "ask_menu", "ask_promotion", "ask_item_info"]:
                    menu_items = await self._get_menu_items(store_id)

                # Generate AI response
                ai_text = self.gemini_service.generate_response(
                    intent=intent,
                    message=original_message,
                    context=context,
                    menu_items=menu_items,
                    conversation_history=conversation_history
                )

                # For some intents, still add rich content
                rich_content = None
                suggested_actions = None

                if intent == "ask_recommendation" and menu_items:
                    # Use AI to pick best recommendations
                    recommendations = self.gemini_service.generate_recommendation(
                        context=context,
                        menu_items=menu_items,
                        limit=3
                    )
                    if recommendations:
                        rich_content = self._build_menu_carousel(recommendations)
                        suggested_actions = [
                            {"type": "quick_reply", "label": "üí∞ Xem khuy·∫øn m√£i", "payload": "c√≥ khuy·∫øn m√£i g√¨"},
                            {"type": "quick_reply", "label": "üõí Xem gi·ªè h√†ng", "payload": "xem gi·ªè h√†ng"}
                        ]

                elif intent == "view_cart":
                    rich_content = self._build_cart_display(context.get('cart_items', []))
                    suggested_actions = [
                        {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω th√™m", "payload": "g·ª£i √Ω m√≥n"},
                        {"type": "quick_reply", "label": "üí∞ Xem khuy·∫øn m√£i", "payload": "c√≥ khuy·∫øn m√£i g√¨"}
                    ]

                elif intent == "payment":
                    # Don't handle payment in chatbot, redirect to cart
                    suggested_actions = [
                        {"type": "quick_reply", "label": "üõí Xem gi·ªè h√†ng", "payload": "xem gi·ªè h√†ng"},
                        {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω th√™m", "payload": "g·ª£i √Ω m√≥n"}
                    ]

                elif intent == "ask_promotion" and menu_items:
                    promo_items = [item for item in menu_items if item.get('has_promotion')]
                    if promo_items:
                        rich_content = self._build_menu_carousel(promo_items[:5])

                return {
                    "text": ai_text,
                    "rich_content": rich_content,
                    "suggested_actions": suggested_actions
                }

            except Exception as e:
                print(f"‚ùå Gemini response generation failed: {e}, falling back to templates")
                import traceback
                traceback.print_exc()

        # Fallback to template-based responses
        # Route to specific generator based on intent
        if intent == "greeting":
            return self._generate_greeting()

        elif intent == "ask_recommendation":
            return await self._generate_recommendation_response(entities, context, store_id)

        elif intent == "ask_item_info":
            return await self._generate_item_info_response(entities, store_id)

        elif intent == "order_item":
            return await self._generate_order_response(entities, context, store_id)

        elif intent == "view_cart":
            return await self._generate_cart_response(context, store_id)

        elif intent == "ask_promotion":
            return await self._generate_promotion_response(store_id)

        elif intent == "payment":
            return await self._generate_payment_response(context, store_id)

        elif intent in ["thank", "goodbye", "help"]:
            return self._generate_simple_response(intent)

        else:
            return self._generate_fallback_response()

    def _generate_greeting(self) -> Dict:
        """Generate greeting response"""
        return {
            "text": random.choice(self.response_templates["greeting"]),
            "rich_content": None,
            "suggested_actions": [
                {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω m√≥n", "payload": "g·ª£i √Ω m√≥n"},
                {"type": "quick_reply", "label": "üí∞ Xem khuy·∫øn m√£i", "payload": "c√≥ khuy·∫øn m√£i g√¨"},
                {"type": "quick_reply", "label": "üìã Xem menu", "payload": "xem menu"}
            ]
        }

    async def _generate_recommendation_response(
        self,
        entities: Dict,
        context: Dict,
        store_id: str
    ) -> Dict:
        """
        Generate simple recommendation response (fallback when AI is not available)
        Just shows popular/promoted items
        """
        # Get menu items with promotions first, then popular items
        menu_items = await self._get_menu_items(store_id)

        if not menu_items:
            return {
                "text": "Hi·ªán t·∫°i qu√°n ch∆∞a c√≥ m√≥n n√†o. Vui l√≤ng quay l·∫°i sau nh√©!",
                "rich_content": None,
                "suggested_actions": []
            }

        # Prioritize promoted items
        promo_items = [item for item in menu_items if item.get('has_promotion')]

        # Get 3 recommendations: promoted first, then others
        recommendations = (promo_items + menu_items)[:3]

        # Generate intro text
        intro = "M√¨nh g·ª£i √Ω cho b·∫°n nh·ªØng m√≥n n√†y nh√©:"

        # Build rich content carousel
        rich_content = self._build_menu_carousel(recommendations)

        return {
            "text": intro,
            "rich_content": rich_content,
            "suggested_actions": [
                {"type": "quick_reply", "label": "üîÑ G·ª£i √Ω m√≥n kh√°c", "payload": "g·ª£i √Ω m√≥n kh√°c"},
                {"type": "quick_reply", "label": "üõí Xem gi·ªè h√†ng", "payload": "xem gi·ªè h√†ng"}
            ]
        }

    async def _generate_item_info_response(
        self,
        entities: Dict,
        store_id: str
    ) -> Dict:
        """
        Generate response with item information
        """
        item_name = entities.get("item_name", "")

        if not item_name:
            return {
                "text": "B·∫°n mu·ªën h·ªèi v·ªÅ m√≥n n√†o ·∫°? C√≥ th·ªÉ n√≥i r√µ t√™n m√≥n gi√∫p m√¨nh nh√©!",
                "rich_content": None,
                "suggested_actions": []
            }

        # Find item by name (fuzzy search)
        item = await self._find_item_by_name(item_name, store_id)

        if not item:
            return {
                "text": f"Xin l·ªói, m√¨nh kh√¥ng t√¨m th·∫•y m√≥n '{item_name}'. B·∫°n c√≥ th·ªÉ xem menu ho·∫∑c g·ª£i √Ω m√≥n nh√©!",
                "rich_content": None,
                "suggested_actions": [
                    {"type": "quick_reply", "label": "üìã Xem menu", "payload": "xem menu"},
                    {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω m√≥n", "payload": "g·ª£i √Ω m√≥n"}
                ]
            }

        # Build detailed item info
        info_text = f"**{item['name']}** - {item['price']:,}ƒë\n\n"

        if item.get("description"):
            info_text += f"{item['description']}\n\n"

        # Add promotion info if available
        if item.get("has_promotion"):
            info_text += f"üéâ {item['promotion_label']} - Gi√° sau gi·∫£m: {item['discounted_price']:,}ƒë\n\n"

        # Get category
        category = await self.db.categories.find_one({"id": item["category_id"]}, {"_id": 0})
        if category:
            info_text += f"üìÅ Danh m·ª•c: {category['name']}\n"

        rich_content = {
            "type": "item_detail_card",
            "item": {
                "id": item["id"],
                "name": item["name"],
                "description": item.get("description"),
                "price": item["price"],
                "discounted_price": item.get("discounted_price"),
                "image_url": item.get("image_url"),
                "has_promotion": item.get("has_promotion", False)
            }
        }

        return {
            "text": info_text,
            "rich_content": rich_content,
            "suggested_actions": [
                {
                    "type": "add_to_cart",
                    "label": "üõí Th√™m v√†o gi·ªè",
                    "payload": f"add_to_cart:{item['id']}"
                },
                {
                    "type": "quick_reply",
                    "label": "üçΩÔ∏è M√≥n kh√°c",
                    "payload": "g·ª£i √Ω m√≥n"
                }
            ]
        }

    async def _generate_order_response(
        self,
        entities: Dict,
        context: Dict,
        store_id: str
    ) -> Dict:
        """
        Generate response for order intent
        """
        item_name = entities.get("item_name", "")
        quantity = entities.get("quantity", 1)

        if not item_name:
            return {
                "text": "B·∫°n mu·ªën g·ªçi m√≥n g√¨ ·∫°? C√≥ th·ªÉ n√≥i r√µ t√™n m√≥n gi√∫p m√¨nh nh√©!",
                "rich_content": None,
                "suggested_actions": []
            }

        # Find item
        item = await self._find_item_by_name(item_name, store_id)

        if not item:
            return {
                "text": f"Xin l·ªói, m√¨nh kh√¥ng t√¨m th·∫•y m√≥n '{item_name}'. B·∫°n xem g·ª£i √Ω nh√©!",
                "rich_content": None,
                "suggested_actions": [
                    {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω m√≥n", "payload": "g·ª£i √Ω m√≥n"}
                ]
            }

        # Calculate total
        price = item.get("discounted_price") or item["price"]
        total = price * quantity

        response_text = f"D·∫°, m√¨nh ƒë√£ th√™m v√†o gi·ªè:\n\n"
        response_text += f"‚Ä¢ {quantity}x **{item['name']}** - {total:,}ƒë\n\n"

        # Get current cart total
        cart_items = context.get("cart_items", [])
        if len(cart_items) > 0:
            response_text += f"üí∞ T·ªïng gi·ªè h√†ng hi·ªán t·∫°i: ... ƒë\n\n"

        response_text += "B·∫°n mu·ªën th√™m g√¨ n·ªØa kh√¥ng?"

        return {
            "text": response_text,
            "rich_content": {
                "type": "order_confirmation",
                "item": item,
                "quantity": quantity,
                "total": total
            },
            "suggested_actions": [
                {"type": "quick_reply", "label": "‚úÖ X√°c nh·∫≠n ƒë·∫∑t m√≥n", "payload": "x√°c nh·∫≠n"},
                {"type": "quick_reply", "label": "üçΩÔ∏è Th√™m m√≥n kh√°c", "payload": "g·ª£i √Ω m√≥n"},
                {"type": "quick_reply", "label": "üõí Xem gi·ªè h√†ng", "payload": "xem gi·ªè h√†ng"}
            ]
        }

    async def _generate_cart_response(
        self,
        context: Dict,
        store_id: str
    ) -> Dict:
        """
        Generate cart display response
        """
        cart_items = context.get("cart_items", [])

        if not cart_items:
            return {
                "text": "Gi·ªè h√†ng c·ªßa b·∫°n ƒëang tr·ªëng. H√£y ch·ªçn m√≥n ƒë·ªÉ b·∫Øt ƒë·∫ßu nh√©! üçΩÔ∏è",
                "rich_content": None,
                "suggested_actions": [
                    {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω m√≥n", "payload": "g·ª£i √Ω m√≥n"}
                ]
            }

        # Get full item details
        items = await self.db.menu_items.find({
            "id": {"$in": cart_items}
        }, {"_id": 0}).to_list(100)

        response_text = "üõí **GI·ªé H√ÄNG C·ª¶A B·∫†N**\n\n"
        total = 0

        for item in items:
            price = item.get("discounted_price") or item["price"]
            response_text += f"‚Ä¢ {item['name']} - {price:,}ƒë\n"
            total += price

        response_text += f"\nüí∞ **T·ªïng c·ªông: {total:,}ƒë**"

        return {
            "text": response_text,
            "rich_content": {
                "type": "cart_summary",
                "items": items,
                "total": total
            },
            "suggested_actions": [
                {"type": "quick_reply", "label": "‚úÖ ƒê·∫∑t m√≥n ngay", "payload": "ƒë·∫∑t m√≥n"},
                {"type": "quick_reply", "label": "üçΩÔ∏è Th√™m m√≥n", "payload": "g·ª£i √Ω m√≥n"}
            ]
        }

    async def _generate_promotion_response(self, store_id: str) -> Dict:
        """
        Generate promotions list response
        """
        from datetime import datetime, timezone

        now = datetime.now(timezone.utc).isoformat()
        promotions = await self.db.promotions.find({
            "store_id": store_id,
            "is_active": True,
            "start_date": {"$lte": now},
            "end_date": {"$gte": now}
        }, {"_id": 0}).to_list(10)

        if not promotions:
            return {
                "text": "Hi·ªán t·∫°i qu√°n ch∆∞a c√≥ ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i n√†o ·∫°. B·∫°n c√≥ th·ªÉ xem menu nh√©!",
                "rich_content": None,
                "suggested_actions": [
                    {"type": "quick_reply", "label": "üìã Xem menu", "payload": "xem menu"}
                ]
            }

        response_text = "üéâ **KHUY·∫æN M√ÉI ƒêANG DI·ªÑN RA**\n\n"

        for promo in promotions:
            response_text += f"‚Ä¢ **{promo['name']}**\n"
            if promo.get("description"):
                response_text += f"  {promo['description']}\n"
            response_text += "\n"

        return {
            "text": response_text,
            "rich_content": {
                "type": "promotions_list",
                "promotions": promotions
            },
            "suggested_actions": [
                {"type": "quick_reply", "label": "üçΩÔ∏è Xem m√≥n gi·∫£m gi√°", "payload": "m√≥n gi·∫£m gi√°"}
            ]
        }

    async def _generate_payment_response(
        self,
        context: Dict,
        store_id: str
    ) -> Dict:
        """
        Redirect user to cart for payment (don't handle payment in chatbot)
        """
        cart_items = context.get("cart_items", [])

        if not cart_items or len(cart_items) == 0:
            return {
                "text": "Gi·ªè h√†ng c·ªßa b·∫°n ƒëang tr·ªëng. H√£y ch·ªçn m√≥n tr∆∞·ªõc nh√©! üçΩÔ∏è",
                "rich_content": None,
                "suggested_actions": [
                    {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω m√≥n", "payload": "g·ª£i √Ω m√≥n"}
                ]
            }

        return {
            "text": "ƒê·ªÉ thanh to√°n, b·∫°n vui l√≤ng m·ªü Gi·ªè h√†ng v√† nh·∫•n n√∫t Thanh to√°n nh√©! üí≥\n\nB·∫°n c√≥ th·ªÉ ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n ti·ªán l·ª£i: Ti·ªÅn m·∫∑t, Chuy·ªÉn kho·∫£n, ho·∫∑c MoMo.",
            "rich_content": None,
            "suggested_actions": [
                {"type": "quick_reply", "label": "üõí Xem gi·ªè h√†ng", "payload": "xem gi·ªè h√†ng"},
                {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω th√™m m√≥n", "payload": "g·ª£i √Ω m√≥n"}
            ]
        }

    def _generate_simple_response(self, intent: str) -> Dict:
        """
        Generate simple template-based response
        """
        return {
            "text": random.choice(self.response_templates[intent]),
            "rich_content": None,
            "suggested_actions": []
        }

    def _generate_fallback_response(self) -> Dict:
        """
        Generate fallback response for unknown intent
        """
        return {
            "text": random.choice(self.response_templates["fallback"]),
            "rich_content": None,
            "suggested_actions": [
                {"type": "quick_reply", "label": "üçΩÔ∏è G·ª£i √Ω m√≥n", "payload": "g·ª£i √Ω m√≥n"},
                {"type": "quick_reply", "label": "üí∞ Xem khuy·∫øn m√£i", "payload": "khuy·∫øn m√£i"},
                {"type": "quick_reply", "label": "‚ùì H∆∞·ªõng d·∫´n", "payload": "gi√∫p t√¥i"}
            ]
        }

    async def _get_menu_items(self, store_id: str) -> List[Dict]:
        """Get all menu items for a store"""
        cursor = self.db.menu_items.find(
            {"store_id": store_id, "is_available": True},
            {"_id": 0}
        ).limit(50)

        items = await cursor.to_list(length=50)
        return items

    def _build_menu_carousel(self, items: List[Dict]) -> Dict:
        """Build menu carousel rich content from items"""
        carousel_items = []
        for item in items:
            # Ensure reasons is always a list
            reason = item.get("recommendation_reason", "M√≥n ngon")
            if isinstance(reason, str):
                reasons = [reason]
            elif isinstance(reason, list):
                reasons = reason
            else:
                reasons = ["M√≥n ngon"]

            carousel_items.append({
                "item_id": item.get("id"),
                "name": item.get("name"),
                "description": item.get("description", ""),
                "price": item.get("price", 0),
                "discounted_price": item.get("discounted_price"),
                "has_promotion": item.get("has_promotion", False),
                "promotion_label": item.get("promotion_label"),
                "image_url": item.get("image_url"),
                "reasons": reasons,
                "actions": [
                    {
                        "type": "add_to_cart",
                        "label": "üõí Th√™m v√†o gi·ªè",
                        "item_id": item.get("id")
                    }
                ]
            })

        return {
            "type": "menu_items_carousel",
            "items": carousel_items
        }

    def _build_cart_display(self, cart_items: List[Dict]) -> Dict:
        """Build cart display rich content"""
        if not cart_items:
            return None

        return {
            "type": "cart_summary",
            "items": [
                {
                    "item_id": item.get("item_id"),
                    "name": item.get("name"),
                    "quantity": item.get("quantity", 1),
                    "price": item.get("price"),
                    "subtotal": item.get("price", 0) * item.get("quantity", 1)
                }
                for item in cart_items
            ],
            "total": sum(item.get("price", 0) * item.get("quantity", 1) for item in cart_items)
        }

    async def _find_item_by_name(
        self,
        item_name: str,
        store_id: str
    ) -> Optional[Dict]:
        """
        Find menu item by name using fuzzy search
        """
        # Simple case-insensitive search
        # TODO: Implement fuzzy matching for better results
        item = await self.db.menu_items.find_one({
            "store_id": store_id,
            "name": {"$regex": item_name, "$options": "i"}
        }, {"_id": 0})

        return item
